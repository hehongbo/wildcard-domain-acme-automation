#!/usr/bin/env node

const https = require("https");
const fs = require("fs");

const boundary = "__BOUNDARY__";
const CRLF = "\r\n"

const bitbucketUsername = process.env.BITBUCKET_USERNAME;
const bitbucketPassword = process.env.BITBUCKET_PASSWORD;
const bitbucketRepoName = process.env.BITBUCKET_REPO_NAME;

const postRequestOptions = {
    hostname: "api.bitbucket.org",
    port: 443,
    path: `/2.0/repositories/${bitbucketRepoName}/downloads`,
    method: "POST",
    headers: {
        "Authorization": "Basic " + Buffer.from(`${bitbucketUsername}:${bitbucketPassword}`).toString("base64"),
        "Content-Type": `multipart/form-data; charset=utf-8; boundary=${boundary}`,
    }
};

function gatherMultipartFormData(objects = [""]) {
    let data = Buffer.from("");
    objects.forEach(object => {
        if (fs.existsSync(object)) {
            data = Buffer.concat([
                data,
                Buffer.from("--" + boundary + CRLF, "utf-8"),
                Buffer.from(`Content-Disposition: form-data; name="files"; filename="${object}"` + CRLF, "utf-8"),
                Buffer.from("Content-Type: application/octet-stream" + CRLF, "utf-8"),
                Buffer.from(CRLF, "utf-8"),
                Buffer.from(fs.readFileSync(`./${object}`)),
                Buffer.from(CRLF, "utf-8")
            ]);
        }
    });
    data = Buffer.concat([
        data,
        Buffer.from("--" + boundary + "--" + CRLF)
    ]);
    return data;
}

function envelopJSONInMultipartFormData(name = "object.json", object = {}) {
    if (typeof object === "object") {
        return Buffer.concat([
            Buffer.from("--" + boundary + CRLF, "utf-8"),
            Buffer.from(`Content-Disposition: form-data; name="files"; filename="${name}"` + CRLF, "utf-8"),
            Buffer.from("Content-Type: application/json" + CRLF, "utf-8"),
            Buffer.from(CRLF, "utf-8"),
            Buffer.from(JSON.stringify(object)),
            Buffer.from(CRLF, "utf-8"),
            Buffer.from("--" + boundary + "--" + CRLF)
        ]);
    }
}

let date = (new Date()).toLocaleString([], {timeZone: process.env.TIMEZONE}).split(",")[0];
let currentMonth = `${date.split("/")[2]}${date.split("/")[0].toString().padStart(2, '0')}`;

let uploadList = [
    `${process.env.DOMAIN}_${currentMonth}_rsa.pem`,
    `${process.env.DOMAIN}_${currentMonth}_ec.pem`
]

fs.renameSync("rsa.cert.pem", uploadList[0]);
fs.renameSync("ec.cert.pem", uploadList[1]);

function publishManifestJSON() {
    https.get(
        `https://api.bitbucket.org/2.0/repositories/${bitbucketRepoName}/downloads`,
        {headers: {"Authorization": postRequestOptions.headers.Authorization}},
        inc => {
            let responseBody = "";
            inc.on("data", chunk => responseBody += chunk);
            inc.on("end", () => {
                let jsonResponse = JSON.parse(responseBody);
                let certRepoUrlList = [];
                certRepoUrlList.push(jsonResponse.values.find(el => el.name === uploadList[0]).links.self.href);
                certRepoUrlList.push(jsonResponse.values.find(el => el.name === uploadList[1]).links.self.href);
                let latestList = {
                    rsa: Object.assign(
                        JSON.parse(fs.readFileSync("rsa.json").toString()),
                        {"certRepoUrl": certRepoUrlList[0]}
                    ),
                    ec: Object.assign(
                        JSON.parse(fs.readFileSync("ec.json").toString()),
                        {"certRepoUrl": certRepoUrlList[1]}
                    )
                };
                let httpRequest_publishManifestJSON = https.request(postRequestOptions, res => {
                    res.on('data', d => process.stdout.write(d));
                });
                httpRequest_publishManifestJSON.write(envelopJSONInMultipartFormData("latest.json", latestList));
                httpRequest_publishManifestJSON.end();
            });
        }
    )
}

let httpRequest_sendingCerts = https.request(postRequestOptions, res => {
    res.on('data', d => process.stdout.write(d));
    res.on('end', d => publishManifestJSON());
});
httpRequest_sendingCerts.write(gatherMultipartFormData(uploadList));
httpRequest_sendingCerts.end();
